/* autogenerated by embedmodel.py.  DO NOT EDIT */

#include "northbound.h"

static const char model[] =
	"// SPDX-License-Identifier: BSD-2-Clause\n"
	"module frr-route-map {\n"
	"  yang-version 1.1;\n"
	"  namespace \"http://frrouting.org/yang/route-map\";\n"
	"  prefix frr-route-map;\n"
	"\n"
	"  import ietf-inet-types {\n"
	"    prefix inet;\n"
	"  }\n"
	"\n"
	"  import frr-filter {\n"
	"    prefix filter;\n"
	"  }\n"
	"\n"
	"  import frr-interface {\n"
	"    prefix frr-interface;\n"
	"  }\n"
	"\n"
	"  organization\n"
	"    \"FRRouting\";\n"
	"  contact\n"
	"    \"FRR Users List:       <mailto:frog@lists.frrouting.org>\n"
	"     FRR Development List: <mailto:dev@lists.frrouting.org>\";\n"
	"  description\n"
	"    \"This module defines route map settings\n"
	"\n"
	"     Copyright 2020 FRRouting\n"
	"\n"
	"     Redistribution and use in source and binary forms, with or without\n"
	"     modification, are permitted provided that the following conditions\n"
	"     are met:\n"
	"\n"
	"     1. Redistributions of source code must retain the above copyright notice,\n"
	"     this list of conditions and the following disclaimer.\n"
	"\n"
	"     2. Redistributions in binary form must reproduce the above copyright\n"
	"     notice, this list of conditions and the following disclaimer in the\n"
	"     documentation and/or other materials provided with the distribution.\n"
	"\n"
	"     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n"
	"     \\\"AS IS\\\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n"
	"     LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n"
	"     A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n"
	"     HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n"
	"     SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n"
	"     LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n"
	"     DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n"
	"     THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n"
	"     (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n"
	"     OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\";\n"
	"\n"
	"  revision 2019-07-01 {\n"
	"    description\n"
	"      \"Initial revision\";\n"
	"  }\n"
	"\n"
	"  identity rmap-match-type {\n"
	"    description\n"
	"      \"Base route-map match-condition\";\n"
	"  }\n"
	"\n"
	"  identity interface {\n"
	"    base rmap-match-type;\n"
	"    description\n"
	"      \"Match interface\";\n"
	"  }\n"
	"\n"
	"  identity ipv4-address-list {\n"
	"    base rmap-match-type;\n"
	"    description\n"
	"      \"Match an IPv4 access-list\";\n"
	"  }\n"
	"\n"
	"  identity ipv4-prefix-list {\n"
	"    base rmap-match-type;\n"
	"    description\n"
	"      \"Match an IPv4 prefix-list\";\n"
	"  }\n"
	"\n"
	"  identity ipv4-next-hop-list {\n"
	"    base rmap-match-type;\n"
	"    description\n"
	"      \"Match an IPv4 next-hop\";\n"
	"  }\n"
	"\n"
	"  identity ipv4-next-hop-prefix-list {\n"
	"    base rmap-match-type;\n"
	"    description\n"
	"      \"Match an IPv4 next-hop prefix list\";\n"
	"  }\n"
	"\n"
	"  identity ipv4-next-hop-type {\n"
	"    base rmap-match-type;\n"
	"    description\n"
	"      \"Match an IPv4 next-hop type\";\n"
	"  }\n"
	"\n"
	"  identity ipv6-address-list {\n"
	"    base rmap-match-type;\n"
	"    description\n"
	"      \"Match an IPv6 access-list\";\n"
	"  }\n"
	"\n"
	"  identity ipv6-prefix-list {\n"
	"    base rmap-match-type;\n"
	"    description\n"
	"      \"Match an IPv6 prefix-list\";\n"
	"  }\n"
	"\n"
	"  identity ipv6-next-hop-list {\n"
	"    base rmap-match-type;\n"
	"    description\n"
	"      \"Match an IPv6 next-hop\";\n"
	"  }\n"
	"\n"
	"  identity ipv6-next-hop-prefix-list {\n"
	"    base rmap-match-type;\n"
	"    description\n"
	"      \"Match an IPv6 next-hop prefix list\";\n"
	"  }\n"
	"\n"
	"  identity ipv6-next-hop-type {\n"
	"    base rmap-match-type;\n"
	"    description\n"
	"      \"Match an IPv6 next-hop type\";\n"
	"  }\n"
	"\n"
	"  identity match-metric {\n"
	"    base rmap-match-type;\n"
	"    description\n"
	"      \"Match a route metric\";\n"
	"  }\n"
	"\n"
	"  identity match-tag {\n"
	"    base rmap-match-type;\n"
	"    description\n"
	"      \"Match a route tag\";\n"
	"  }\n"
	"\n"
	"  identity rmap-set-type {\n"
	"    description\n"
	"      \"Base route-map set-action\";\n"
	"  }\n"
	"\n"
	"  identity ipv4-next-hop {\n"
	"    base rmap-set-type;\n"
	"    description\n"
	"      \"Set IPv4 address of the next hop\";\n"
	"  }\n"
	"\n"
	"  identity ipv6-next-hop {\n"
	"    base rmap-set-type;\n"
	"    description\n"
	"      \"Set IPv6 address of the next hop\";\n"
	"  }\n"
	"\n"
	"  identity set-metric {\n"
	"    base rmap-set-type;\n"
	"    description\n"
	"      \"Set prefix/route metric\";\n"
	"  }\n"
	"\n"
	"  identity set-min-metric {\n"
	"    base rmap-set-type;\n"
	"    description\n"
	"      \"Set minimum prefix/route metric\";\n"
	"  }\n"
	"\n"
	"    identity set-max-metric {\n"
	"    base rmap-set-type;\n"
	"    description\n"
	"      \"Set maximum prefix/route metric\";\n"
	"  }\n"
	"\n"
	"  identity set-tag {\n"
	"    base rmap-set-type;\n"
	"    description\n"
	"      \"Set tag\";\n"
	"  }\n"
	"\n"
	"  identity set-sr-te-color {\n"
	"    base rmap-set-type;\n"
	"    description\n"
	"      \"Set Color of the SR-TE\";\n"
	"  }\n"
	"\n"
	"  typedef route-map-sequence {\n"
	"    type uint16 {\n"
	"      range \"1..65535\";\n"
	"    }\n"
	"    description\n"
	"      \"Route map valid sequence numbers\";\n"
	"  }\n"
	"\n"
	"  typedef route-map-name {\n"
	"    type string;\n"
	"    description\n"
	"      \"Route map name format\";\n"
	"  }\n"
	"\n"
	"  typedef route-map-ref {\n"
	"    type leafref {\n"
	"      path \"/frr-route-map:lib/frr-route-map:route-map/frr-route-map:name\";\n"
	"      require-instance false;\n"
	"    }\n"
	"    description\n"
	"      \"Reference to a route-map.\";\n"
	"  }\n"
	"\n"
	"  grouping rmap-match-condition {\n"
	"    container rmap-match-condition {\n"
	"      choice match-condition {\n"
	"        description\n"
	"          \"Value to match (interpretation depends on condition type)\";\n"
	"        case interface {\n"
	"          when \"derived-from-or-self(../condition, \'interface\')\";\n"
	"          leaf interface {\n"
	"            type frr-interface:interface-ref;\n"
	"          }\n"
	"        }\n"
	"\n"
	"        case list-name {\n"
	"          when \"derived-from-or-self(../condition, \'ipv4-address-list\') or \"\n"
	"             + \"derived-from-or-self(../condition, \'ipv4-prefix-list\') or \"\n"
	"             + \"derived-from-or-self(../condition, \'ipv4-next-hop-list\') or \"\n"
	"             + \"derived-from-or-self(../condition, \'ipv4-next-hop-prefix-list\') or \"\n"
	"             + \"derived-from-or-self(../condition, \'ipv6-address-list\') or \"\n"
	"             + \"derived-from-or-self(../condition, \'ipv6-next-hop-list\') or \"\n"
	"             + \"derived-from-or-self(../condition, \'ipv6-next-hop-prefix-list\') or \"\n"
	"             + \"derived-from-or-self(../condition, \'ipv6-prefix-list\')\";\n"
	"          leaf list-name {\n"
	"            type filter:access-list-name;\n"
	"          }\n"
	"        }\n"
	"\n"
	"        case ipv4-next-hop-type {\n"
	"          when \"derived-from-or-self(../condition, \'ipv4-next-hop-type\')\";\n"
	"          leaf ipv4-next-hop-type {\n"
	"            type enumeration {\n"
	"              enum \"blackhole\" {\n"
	"                value 0;\n"
	"              }\n"
	"            }\n"
	"          }\n"
	"        }\n"
	"\n"
	"        case ipv6-next-hop-type {\n"
	"          when \"derived-from-or-self(../condition, \'ipv6-next-hop-type\')\";\n"
	"          leaf ipv6-next-hop-type {\n"
	"            type enumeration {\n"
	"              enum \"blackhole\" {\n"
	"                value 0;\n"
	"              }\n"
	"            }\n"
	"          }\n"
	"        }\n"
	"\n"
	"        case match-metric {\n"
	"          when \"derived-from-or-self(../condition, \'match-metric\')\";\n"
	"          leaf metric {\n"
	"            type uint32 {\n"
	"              range \"1..4294967295\";\n"
	"            }\n"
	"          }\n"
	"        }\n"
	"\n"
	"        case match-tag {\n"
	"          when \"derived-from-or-self(../condition, \'match-tag\')\";\n"
	"          leaf tag {\n"
	"            type uint32 {\n"
	"              range \"0..4294967295\";\n"
	"            }\n"
	"          }\n"
	"        }\n"
	"      }\n"
	"    }\n"
	"  }\n"
	"\n"
	"  grouping rmap-set-action {\n"
	"    container rmap-set-action {\n"
	"      choice set-action {\n"
	"        description\n"
	"          \"Value to set (interpretation depends on action-type)\";\n"
	"        case ipv4-address {\n"
	"          when \"derived-from-or-self(../action, \'ipv4-next-hop\')\";\n"
	"          leaf ipv4-address {\n"
	"            type inet:ipv4-address;\n"
	"            description\n"
	"              \"IPv4 address\";\n"
	"          }\n"
	"        }\n"
	"\n"
	"        case ipv6-address {\n"
	"          when \"derived-from-or-self(../action, \'ipv6-next-hop\')\";\n"
	"          leaf ipv6-address {\n"
	"            type inet:ipv6-address;\n"
	"            description\n"
	"              \"IPv6 address\";\n"
	"          }\n"
	"        }\n"
	"\n"
	"        case set-metric {\n"
	"          when \"derived-from-or-self(../action, \'set-metric\')\";\n"
	"          choice metric-value {\n"
	"            description\n"
	"              \"Metric to set or use\";\n"
	"            case value {\n"
	"              leaf value {\n"
	"                type uint32 {\n"
	"                  range \"0..4294967295\";\n"
	"                }\n"
	"                description\n"
	"                  \"Use the following metric value\";\n"
	"              }\n"
	"            }\n"
	"\n"
	"            case add-metric {\n"
	"              leaf add-metric {\n"
	"                description \"Add value to metric.\";\n"
	"                type uint32 {\n"
	"                  range \"0..4294967295\";\n"
	"                }\n"
	"              }\n"
	"            }\n"
	"\n"
	"            case subtract-metric {\n"
	"              leaf subtract-metric {\n"
	"                description \"Subtract value from metric.\";\n"
	"                type uint32 {\n"
	"                  range \"0..4294967295\";\n"
	"                }\n"
	"              }\n"
	"            }\n"
	"\n"
	"            case use-round-trip-time {\n"
	"              leaf use-round-trip-time {\n"
	"                type boolean;\n"
	"                description\n"
	"                  \"Use the round trip time as metric\";\n"
	"              }\n"
	"            }\n"
	"\n"
	"            case add-round-trip-time {\n"
	"              leaf add-round-trip-time {\n"
	"                type boolean;\n"
	"                description\n"
	"                  \"Add round trip time to metric\";\n"
	"              }\n"
	"            }\n"
	"\n"
	"            case subtract-round-trip-time {\n"
	"              leaf subtract-round-trip-time {\n"
	"                type boolean;\n"
	"                description\n"
	"                  \"Subtract round trip time to metric\";\n"
	"              }\n"
	"            }\n"
	"          }\n"
	"        }\n"
	"\n"
	"        case set-min-metric {\n"
	"          when \"derived-from-or-self(../action, \'set-min-metric\')\";\n"
	"          choice minimun-metric-value {\n"
	"            description\n"
	"              \"Mimimum metric to set or use\";\n"
	"            case min-metric {\n"
	"              leaf min-metric {\n"
	"                type uint32 {\n"
	"                  range \"0..4294967295\";\n"
	"                }\n"
	"                description\n"
	"                  \"Use the following mimumn metric value\";\n"
	"              }\n"
	"            }\n"
	"          }\n"
	"        }\n"
	"\n"
	"        case set-max-metric {\n"
	"          when \"derived-from-or-self(../action, \'set-max-metric\')\";\n"
	"          choice maximum-metric-value {\n"
	"            description\n"
	"              \"Maximum metric to set or use\";\n"
	"            case max-metric {\n"
	"              leaf max-metric {\n"
	"                type uint32 {\n"
	"                  range \"0..4294967295\";\n"
	"                }\n"
	"                description\n"
	"                  \"Use the following maximum metric value\";\n"
	"              }\n"
	"            }\n"
	"          }\n"
	"        }\n"
	"        case set-tag {\n"
	"          when \"derived-from-or-self(../action, \'set-tag\')\";\n"
	"          leaf tag {\n"
	"            type uint32 {\n"
	"              range \"0..4294967295\";\n"
	"            }\n"
	"            description\n"
	"              \"Tag value\";\n"
	"          }\n"
	"        }\n"
	"\n"
	"        case set-sr-te-color {\n"
	"          when \"derived-from-or-self(../action, \'set-sr-te-color\')\";\n"
	"          leaf policy {\n"
	"            type string;\n"
	"            description\n"
	"              \"Color of the SR-TE Policies to match with\";\n"
	"          }\n"
	"        }\n"
	"      }\n"
	"    }\n"
	"  }\n"
	"\n"
	"  container lib {\n"
	"    list route-map {\n"
	"      key \"name\";\n"
	"      description\n"
	"        \"Route map instance\";\n"
	"      leaf name {\n"
	"        type route-map-name;\n"
	"        description\n"
	"          \"Route map instance name\";\n"
	"      }\n"
	"      leaf optimization-disabled {\n"
	"        type boolean;\n"
	"        default false;\n"
	"        description \"Disables or enables the optimization\";\n"
	"      }\n"
	"\n"
	"      list entry {\n"
	"        key \"sequence\";\n"
	"        description\n"
	"          \"Route map entry\";\n"
	"        leaf sequence {\n"
	"          type route-map-sequence;\n"
	"          description\n"
	"            \"Route map instance priority (low number means higher priority)\";\n"
	"        }\n"
	"\n"
	"        leaf description {\n"
	"          type string;\n"
	"          description\n"
	"            \"Route map description\";\n"
	"        }\n"
	"\n"
	"        leaf action {\n"
	"          type enumeration {\n"
	"            enum \"permit\" {\n"
	"              value 0;\n"
	"              description\n"
	"                \"Executes configured action and permits the prefix/route\n"
	"                 if the conditions matched. An alternative exit action can\n"
	"                 be configured to continue processing the route map list\n"
	"                 or jump to process another route map.\";\n"
	"            }\n"
	"            enum \"deny\" {\n"
	"              value 1;\n"
	"              description\n"
	"                \"If all conditions are met the prefix/route is denied and\n"
	"                 route map processing stops.\";\n"
	"            }\n"
	"          }\n"
	"          mandatory true;\n"
	"          description\n"
	"            \"Route map actions: permit (executes action), deny (quits evaluation)\";\n"
	"        }\n"
	"\n"
	"        leaf call {\n"
	"          type route-map-name;\n"
	"          description\n"
	"            \"Call another route map before calling `exit-policy`. If the\n"
	"             called route map returns deny then this route map will also\n"
	"             return deny\";\n"
	"        }\n"
	"\n"
	"        leaf exit-policy {\n"
	"          type enumeration {\n"
	"            enum \"permit-or-deny\" {\n"
	"              value 0;\n"
	"              description\n"
	"                \"End route map evaluation and return\";\n"
	"            }\n"
	"            enum \"next\" {\n"
	"              value 1;\n"
	"              description\n"
	"                \"Proceed evaluating next route map entry per sequence\";\n"
	"            }\n"
	"            enum \"goto\" {\n"
	"              value 2;\n"
	"              description\n"
	"                \"Go to route map entry with the provided sequence number\";\n"
	"            }\n"
	"          }\n"
	"          default \"permit-or-deny\";\n"
	"          description\n"
	"            \"What do to after route map successful match, set and call\";\n"
	"        }\n"
	"\n"
	"        leaf goto-value {\n"
	"          when \"../exit-policy = \'goto\'\";\n"
	"          type route-map-sequence;\n"
	"          mandatory true;\n"
	"          description\n"
	"            \"Sequence number to jump (when using `goto` exit policy)\";\n"
	"        }\n"
	"\n"
	"        list match-condition {\n"
	"          key \"condition\";\n"
	"          description\n"
	"            \"Route map match conditions\";\n"
	"          leaf condition {\n"
	"            type identityref {\n"
	"              base rmap-match-type;\n"
	"            }\n"
	"            description\n"
	"              \"Match condition\";\n"
	"          }\n"
	"\n"
	"          uses rmap-match-condition;\n"
	"        }\n"
	"\n"
	"        list set-action {\n"
	"          key \"action\";\n"
	"          description\n"
	"            \"Route map set actions\";\n"
	"          leaf action {\n"
	"            type identityref {\n"
	"              base rmap-set-type;\n"
	"            }\n"
	"            description\n"
	"              \"Action to do when the route map matches\";\n"
	"          }\n"
	"\n"
	"          uses rmap-set-action;\n"
	"        }\n"
	"      }\n"
	"    }\n"
	"  }\n"
	"}\n"
	"";

static struct yang_module_embed embed = {
	.mod_name = "frr-route-map",
	.mod_rev = "2019-07-01",
	.sub_mod_name = "",
	.sub_mod_rev = "",
	.data = model,
	.format = LYS_IN_YANG,
};

static void embed_register(void) __attribute__((_CONSTRUCTOR(2000)));
static void embed_register(void)
{
	yang_module_embed(&embed);
}
